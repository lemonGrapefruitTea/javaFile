# 										

## java基础

### java容器

### 	list集合

#### ArrayList 的底层数据结构是什么？

​			ArrayList底层数据结构是数组

#### LinkedList 的底层数据结构是什么？

​			LinkedList底层数据结构是链表

#### ArrayList 怎么扩容？一次扩多少？

​			每一次扩原来的1.5倍。初始化的值为10，当第一11个元素进来的时候会扩容到15，16个元素后扩容到22，空间扩完容之后，会调用arraycopy来对数组进行拷贝。

#### Vector 你了解吗？

​			Vector是线程安全的，扩容是原来的两倍（基本不用）



#### ArrayList 是线程安全的吗？

​			不是线程安全，多线程的情况下会出现写时覆盖的问题。



#### 那些是线程安全的集合呢？

​				Vector、 Collections工具类的synchronizedList()方法封装ArrayList、 JUC包下的 CopyOnWriteArrayList



#### CopyOnWriteArrayList 它的添加元素是怎么实现的

​				在add()方法其实他会 加lock 锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组。
​				加lock锁，复制旧数组，创建一个长度加一的新数组，将元素添加到新数组中，把array的指向改为新数组

​			

#### 	CopyOnWriteArrayList 缺点

​				只能保证**最终一致性**，复制数组 **消耗内存**



### map集合

​					![image-20220623160651546](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220623160651546.png)

#### 当new一个HashMap的时候，会发生什么你知道吗？

​		最主要的就是**指定初始值大小和负载因子的大小**

​		如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75

​		HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。



#### HashMap动态扩容是扩容多少？

​			原始大小的**两倍**



#### 为什么HashMap的大小只能是2次幂?

​		因为只有大小为2次幂时，才能合理用位运算替代取模



#### 在put元素的时候，传递的Key是怎么算哈希值的？

​		实现就在hash方法上，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。

   **可以增加了随机性，减少了碰撞冲突的可能性**

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtv6bnxj0hj618q06m3z802.jpg)



#### 简单说下HashMap put流程

​			**1、计算Hash**

​			**2、是否发生hash碰撞**

​			**3、无碰撞直接进入数组**

​			**4、有碰撞判断此时的数据结构（为红黑树还是链表）**

​			**5、key完全相同时，需要替换**

​			**6、是否需要扩容**



#### 那在HashMap中是怎么判断一个元素是否相同的呢？

​           先比较hash值，随后会用==运算符和equals()来判断该元素是否相同



#### 那什么情况拿下才会用到红黑树呢？

​			**当数组的大小大于64且链表的大小大于8**的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。



#### 你能给我讲讲JDK 7 和JDK8中HashMap的区别吗？

​			比如JDK 7 的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7 的HashMap还没有引入红黑树….





### java并发

#### 		wait和sleep有什么区别？

​				1、sleep是Thread类的静态方法，wait是Object的方法

​				2、sleep不会释放锁，wai会释放锁

​				3、sleep不依赖synchronized，wait依赖synchronized

​				4、slepp必须要捕获异常，wait不需要捕获异常



#### 		synchronized 和 Lock 区别?

​				1、Synchronized 内置的Java关键字， Lock 是一个Java类

​				2、Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁，**死锁**

​				3、Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；

​				4、Synchronized 可重入锁，非公平，不可以中断的；Lock ，可重入锁，非公平（可以自己设置），可以 判断锁



#### 		 什么是JMM？

​				JMM ： **Java内存模型，是一种概念！约定**！（不存在的东西）

​		

#### 		关于JMM的一些同步的约定

​				1、线程解锁前，必须把共享变量**立刻**刷回主存。

​				2、线程加锁前，必须读取主存中的最新值到工作内存中！

​				3、加锁和解锁是同一把锁



#### 		谈谈你对 volatile 的理解

​				volatile 是 java虚拟机提供**轻量级的同步机制**，特性：**保证可见性、不保证原子性、禁止指令重排**



#### 		什么是CAS？

​				**比较并交换**，比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作，如果不是就一直循环！

​				**缺点：**

​						**循环会耗时**

​						**一次性只能保证一个共享变量的原子性**

​						**ABA问题**

##### 					原子引用

​				使用  **AtomicStampedReference** 解决ABA问题，引入原子引用，它的对应思想就是：**乐观锁**



#### 什么是公平锁、非公平锁？

​				**公平锁：**非常公平，不能够插队，必须先来后到

​				**非公平锁：**非常不公平，可以插队



#### 什么是可重入锁？

​				可重入锁（递归锁），意思就是当拿到了外层的锁之后，就可以拿到里面的锁，自动获得锁，前提是**同一个锁对象**。

​		

#### 什么是死锁，导致死锁的原因是什么？

​		A对象持有A锁，试图获取B锁，B对象持有B锁，试图获取A锁。



#### 死锁怎么排除？

​		1、使用 **jps -l** 定位进程号

​		2、使用 **jstack 进程号** 找到死锁问题



#### 什么是读写锁？

​		**独占锁（写锁）**：一次只能被一个线程占有

​		**共享锁（读锁）**：多个线程可以同时占有

​		

#### CountDownLatch、CyclicBarrier、Semaphore辅助类分别有什么用？

​		**CountDownLatch：**每次有线程调用countDown()方法数量 -1 ，假设计数器变为0， countDownLatch.await() 就会被唤醒，继续执行！（这是一个一次性的现象）

​		**CyclicBarrier：**允许一组线程全部等待彼此达到共同屏障点的同步辅助。（加法计数器）

​		**Semaphore：一个计数信号量**

​				semaphore.acquire() 获得，假设如果已经满了，等待，等待被释放为止！

​				semaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！

​				**作用：**多个共享资源互斥的使用！并发限流，控制最大的线程数！



#### 什么是阻塞队列？

​		**BlockingQueue**：写入：如果队列满了，就必须阻塞等待，取：如果队列是空的，必须阻塞等待生产



#### 使用线程池的好处是什么？

​		1、降低资源的消耗  2、提高响应的速度   3、方便管理

​		**线程可以复用、可以控制最大并发数、管理线程**

​		

#### 线程池的参数有哪些？

​		有7个： 核心线程数	最大线程数	空闲存活时间	空闲存活时间单位	阻塞队列	线程工厂	拒绝策略

​		

#### 线程池的复用原理

​		核心原理在于线程池对Thread进行了封装，每个线程去执行 循环任务，如果有任务则直接执行。

​		

### java虚拟机

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fbbsmax.ikafan.com%2Fstatic%2FL3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xMDYxMDc0LzIwMTkxMS8xMDYxMDc0LTIwMTkxMTI3MTYyMTIzNzQ2LTE1ODg0NDI0MDAucG5n.jpg&refer=http%3A%2F%2Fbbsmax.ikafan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659001061&t=ae9dca80f878a32c246cba7699539f48)



#### 	

#### Java文件执行的过程是什么样子的？

![image-20220624114210925](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624114210925.png)

​		

#### Java类加载器有哪些？

​				JDK自带有三个类加载器：**bootstrap ClassLoader、ExtClassLoader、AppClassLoader**

​				**bootstrap ClassLoader：**负责加载 %JAVA_HOME%lib 下的jar包和class

​				**ExtClassLoader：**负责加载 %JAVA_HOME%/lib/ext 文件夹下的jar包和class

​				**AppClassLoader:**  负责加载classpath下的类文件



#### 双亲委托模型

​				**向上委派：**实际上就是查找缓存是否加载了该类，有则直接返回，没有继续向上

​				**向下查找：**查找加载路径，有则加载返回，没有则继续向下查找

​				**好处：**主要是为了**安全性**，**避免用户自己编写的类动态替换 Java的一些核心类**，比如 String。

​						**同时也避免了类的重复加载**，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不

​				同的 ClassLoader加载就是不同的两个类

​		

#### JVM内存结构

​				**虚拟机栈：**在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。

​				**本地方法栈：**本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是native方法

​				**程序计数器：**主要用来记录各个线程执行的字节码地址

​				**方法区：**JDK7及之前叫 " 永久代 "，JDK8及之后  " 元空间 " ，存放类的信息，常量池、方法数据、方法代码

​				**堆：** 堆是JVM上最大的内存区域，我们申请的几乎所有的对象，都是存储在堆中。



![img](https://tva1.sinaimg.cn/large/008i3skNgy1gs784qdq5sj314z0u04dh.jpg)



#### JVM中 虚拟机栈

​				每个线程在创建的时候都会创建一个 【虚拟机栈】，每次方法调用都会创建一个 【栈桢】，每个 【栈桢】会包含几个内容：**局部变量表、操作数栈、动态链接、返回地址**

​				![image-20220624155741991](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624155741991.png)



#### JVM中 堆的内存区域

​			【堆】是线程共享的区域，几乎类的实例和数组分配内存都来自它

​			【堆】被划分为 【新生代】和 【老年代】，【新生代】又被划分为 Eden 和 Survivor 区，Survivor区由 S0 S1组成



​			![image-20220624162854954](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624162854954.png)



#### 永久代 变成 元空间 后，它们有什么区别吗？

​			最主要的区别就是：[ 元空间 ] 存储不在虚拟机中，而是使用本地内存**，JVM不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。



####  	垃圾回收机制

​			**GC是如何判断对象可以被回收的？**

​						**引用计数法：**每个对象有一个引用计数属性，新增一个引用计数器加1，引用释放计数器减1，0时可以回收（不推荐）

​						**可达性分析法：**它从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收

​			**GC Roots的对象有那些？：**

​							**虚拟机栈中引用的对象**

​							**方法区中静态属性引用的对象**

​							**方法区中常量引用的对象**	

​							**本地方法栈中引用的对象**

​						

#### 常见的垃圾回收算法有那些？

​			标记清除、标记复制、标记整理



#### ⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？

		1. ⾸先把字节码⽂件内容加载到⽅法区 

2. 然后再根据类信息在堆区创建对象 

3. 对象⾸先会分配在堆区中年轻代的Eden区，经过⼀次Minor GC后，对象如果存活，就会进⼊ 

​	Suvivor区。在后续的每次Minor GC中，如果对象⼀直存活，就会在Suvivor区来回拷⻉，每移动⼀次，年龄加1 

4. 当年龄超过15后，对象依然存活，对象就会进⼊⽼年代 

5. 如果经过Full GC，被标记为垃圾对象，那么就会被GC线程清理掉 





### JVM调优



#### 你平时工作用过的jvm调优参数有哪儿些？

- **-Xms**	堆初始大小内存，默认为物理内存 1/61 

  - **-Xmx**   堆最大分配内存，默认为物理内存的 1/4

  - **-Xss**    设置单个线程的大小，一般默认为 512K ~ 1024K

  - **-Xmn**    设置年轻代大小

  - **-XX:MetaspaceSize**   设置元空间大小

  - **-XX:+PrintGCDetails**  输出详细GC收集日志信息

    

#### 强引用、软引用、弱引用、虚引用分别是什么?

​			**强引用：**就算是出现了OOM也不会对该对象进行回收

​			**软引用：**内存够用的时候就保留，不够用就回收

​			**弱引用：**不管内存是否够用都回收

​			**虚引用：**虚引用必定被回收



#### 谈谈见过的OOM异常

- Java.lang.StackOverflowError   使用方法递归调用的时候可能会出现
- Java.lang.OutOfMemoryError:Java heap space   堆内存溢出
- Java.lang.OutOfMemeoryError:Metaspace   元空间内存溢出



#### 生产环境服务器变慢，诊断思路和性能评估谈谈?

1. **jps**: 虚拟机进程状态工具
2. **jinfo**： java配置信息工具
3. **jmap**：内存映像工具
4. **jstat**：统计信息监控工具







## Spring



#### 什么是Spring？

​			spring是一个轻量级、面向切面的容器框架，主要核心有IOC、AOP



#### 谈谈你对AOP的理解？

​			AOP: 是将程序中交叉业务逻辑，比如安全、日志、事物等等，封装成一个切面，然后注入到目标对象中去，也就是具体的业务逻辑中去。

​			AOP可以对某些对象的功能进行增强，比如增强目标对象中的方法，还可以在执行某个方法之前或者之后额外做一些事情。



#### 谈谈你对IOC的理解？

​			IOC容器有三大核心点：**IOC容器**、**控制反转**、**依赖注入**

​			**IOC容器：**实际上就是一个map，里面存放各种对象，在项目启动的时候会读取配置文件里面的bean节点，和扫描添加了@Service、@Controller、@Component、@repository注解的类，通过反射创建对象到map里面，需要使用是就可以用@Autowired、@Resource 注解获取到对象

​			**控制反转：**如果没有引入IOC容器之前，对象A调用对象B的过程是需要我们自己去创建的，引入

​			**依赖注入：**依赖注入是实现IOC容器的方法，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象中去。



#### 描述一下bean的生命周期？

​			1、解析类得到BeanDefinition

​			2、如果有多个构造方法则需要推断构造方法

​			3、确定好构造方法后，进行实例化得到一个对象

​			4、对对象中加了@Autowired注解的属性进行属性填充

​			5、回调Aware方法

​			6、调用BeanPostProcessor的初始化前的方法，调用初始化方法

​			7、调用BeanPostProcessor的初始化后的方法，这里会进行AOP处理

​			8、如果当前创建的bean是单例的，则会把bean放出单例池

​			9、使用bean

​			10、Spring容器关闭时调用DisposableBean中destory方法

​			到此整个生命周期结束



#### Spring中单例bean是线程安全的吗？

​			**不是线程安全，**Spring容器并没有对单例的bean进行线程安全的处理。



#### BeanFactory和ApplicationContext有什么区别？

​			**BeanFactory** 采用的是延迟加载的形式来注入Bean的。

​			**ApplicationContext**  是在容器启动时，一次性加载了所有的Bean。



#### Spring框架中的设计模式都有那些？

​			**单例模式：**单例Bean 

​			**构造器模式：**

​			**适配器模式：**

​			**动态代理：**

​			**观察者模式：**



​			**装饰器模式：**

​			**工厂模式：**

​			**策略模式：**

​			**原型模式：**



#### Spring事物的实现方式和隔离级别？

​			在使用Spring框架时，可以有两种使用事务的方式，一种是编程式（自己写 commit ）、一种是申明式的（@Transactional）

​			**@Transactional：**在方法上加了 @Transactional 注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，如果这个方法上存在 @Transactional 注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行业务逻辑方法，如果执行业务逻辑方法没有异常，将事务进行提交，如果有异常，则进行事务回滚。 



#### Spring事物什么时候会失效？

​			1、发生调用，类⾥⾯使⽤this调⽤本类的⽅法

​			2、方法不是public的，@Transactionl 事务不会生效

​			3、数据库不支持事务

​			4、没有被spring管理

​			5、异常被吃掉，事务不会回滚



#### 什么是bean的自动装配，有哪些方式？

​			开启自动装配，只需要在xml配置文件中定义 autowire 属性，可以根据 

​			**byName**：属性名进行自动装配  或者 **byType**：类型进行自动装配



#### Spring的三级缓存你知道吗？

​			![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtyval7yubj60va0g8gmb02.jpg)

​		Spring的三级缓存其实就是三个**Map**

​		**singletonObjects：** 一级，日常实际获取Bean的地方（成品）

​		**earlySingletonObjects：**二级，还没进行属性注入，由三级缓存放进来（半成品）

​		**singletonFactories：**三级，Value是一个对象工厂（工厂）

​		**执行流程：**

​					1、**A** 创建过程中需要 **B**，于是 **A** 将自己放到三级缓存里面，去实例化 **B**

​					2、**B** 实例化的时候发现需要 **A** ，于是 **B** 先查一级缓存，发现没有，再查二级缓存，还是没有，再查三级缓存，

​			找到了A，然后把三级缓存里面的这个 **A** 放到二级缓存里面，并删除三级缓存里面的 **A**

​					3、**B **顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态），然后回来接着创建 **A**，

​			此时B已经创建结束，直接从一级缓存里面拿到 **B**，然后完成创建，并将A自己放到一级缓存里面。

#### Spring依赖注入有几种方式？

​		有四种：**set()方法注入 、 构造器注入、 基于注解的注入**

#### Spring怎么解决循环依赖的问题？

​		Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过**三级缓存**来解决的。



## SpringMVC

#### 	SpringMVC 工作流程

​		1）用户发送请求至前端控制器 DispatcherServlet。 

​		2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。

​		3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器

​		(如果有则生成)一并返回给 DispatcherServlet。 

​		4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。

​		5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器) 

​		6）Controller 执行完成返回 ModelAndView。 

​		7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。

​		8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。

​		9）ViewReslover 解析后返回具体 View。

​		10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。

​		11）DispatcherServlet 响应用户。



#### Spring MVC的主要组件？

​		1、**HandlerMapping**：处理器映射器，根据用户请求的资源uri来查找Handler的

​		2、**HandlerAdapter**：适配器

​		3、**ViewReslover**：视图解析器

​		4、HandlerExceptionResolver

​		..................



## SpringBoot



#### Spring Boot中常用注解基底层

​		1、**@SrpingBootApplication** 注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，

这三个注解是：

​				a. **@SpringBootConfiguration**： 这个注解实际就是一个 @Configuration，表示启动类也是一个配置类

​				b. **@EnableAutoConfiguration**： 向Spring容器中导入一个Selector，用来加载ClassPath下 SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean

​				c. **@ComponentScan**：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前⽬录 

​		 2、**@Bean**注解：⽤来定义Bean，类似于XML中的**<bean>**标签，Spring在启动时，会对加了@Bean注 

解的⽅法进⾏解析，将⽅法的名字做为beanName，并通过执⾏⽅法得到bean对象 

​		3、**@Controller、@Service、@ResponseBody、@Autowired**都可以说 



#### SpringBoot 是如何启动Tomcat的

​		1、⾸先，SpringBoot在启动时会先创建⼀个Spring容器 

​		2、在创建Spring容器过程中，会利⽤**@ConditionalOnClass**技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会⽣成⼀个启动Tomcat的Bean 

​		3、Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端⼝等，然后启动Tomcat 





## MySql

#### 索引的基本原理是什么？	

​		索引的原理：**就是把无序的数据变为有序的查询**

​		

#### 索引设计的原则有哪些？

  1. 适合索引的列是出现在where子句中的列

  2. 基数较小的表，没有必要在此列建立索引

  3. 更新频繁字段不适合创建索引

  4. 若是不能有效区分数据的列不适合做索引列 (如男、女、未知，最多就三种，区分实在太低)

  5. 尽量的扩展索引，不要新建索引。

  6. 过度索引会消耗磁盘空间。

     

#### 锁的类型有哪些？

​		**共享锁  (读锁)：**数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。（避免出现重复读的问题）

​		**排他锁（写锁）：**数据加上写锁后，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。（避免了出现脏数据和脏读的问题）

​		**表锁：**表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能 

进行对表进行访问；		

​		**行锁：**行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不 

能访问，其他的记录可正常访问； 



#### 对慢查询的SQL怎么优化？

​		**首先分析语句：**看看是不是加载了额外的数据，可能查询多余的行并且抛弃掉了，可能加载了许多并不需要的列，对语句进行分析重写。

​		**分析语句的执行计划：**然后获得其使用索引的情况，修改语句或者修改索引，使得语句尽可能的命中索引。

​		如果前两步都无法进行优化，那么就要考虑是不是数据量太大了，就需要进行横向或者纵向的分表啦





#### 事务的基本特性是什么？

​		**原子性：**是一个事务中的操作要么全部成功，要么全部失败（底层依赖 **undo log** 来实现）

​		**一致性：**一致性是事务的目的，需要通过应用程序来保证一致性（原子性、隔离性、持久性均是**为了保障一致性的手段**）

​		**隔离性：**事务之间需要有隔离，互不影响 （隔离级别底层是**锁**）

​		**持久性：**是一旦事务提交，所做的修改就会永久保存到数据库中（而持久性由 **redo log** 日志来保证）



#### 事务的隔离级别有哪些？

​		**read uncommit 读未提交：**可能会读到其他事务未提交的数据，也叫做脏读。

​		**read commit 读已提交：**两次读取结果不一致，叫做不可重复读。

​		**repeatable read 可重复复读：**这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。

​		**serializable 串行：**一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

​			**脏读：**某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事	务所读取的数据就会是不正确的。

​			**不可重复读：**在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

​			**幻读：**在一个事务的两次查询中数据笔数不一致



#### ACID靠什么保证的？

​		**A 原子性由undo log日志保证**，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

​		**C 一致性由其他三大特性保证**、程序代码要保证业务上的一致性

​		**I 隔离性由MVCC来保证**

​		**D 持久性由内存+redo log来保证**，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可

​		以从redo log恢复



#### 什么是MVCC？

​		MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同

实现不同的隔离级别。



#### 简述MyISAM和InnoDB的区别

​		**MyISAM：**

​			**不支持事务，但是每次查询都是原子的**

​			**支持表级锁，每次操作都是对真个表加锁**

​			**存储表的总行数**

​		**InnoDb：**

​			**支持ACID的事务，支持事务的四种隔离级别**

​			**支持行级锁及外键约束，可以支持写并发**

​			**不存储总行数**



#### mysql聚簇和非聚簇索引的区别?

​		**都是B+树的数据结构**

​		**聚簇索引：**将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数

据，数据的物理存放顺序与索引顺序是一致的

​		**非聚簇索引：**叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置

再取磁盘查找数据



## Redis

### redis的数据类型有哪些？

​	redis的数据类型有8种，分别是 String、List、Hash、Set、ZSet、地址位置、HyperLoglog、BitMap



### redis的持久化机制有几种？

​	持久化机制有两种：RDB和AOF

​				**RDB 快照：**

​			在指定的时间间隔内将内存中的数据集快照写入磁盘，fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件

​				**优点：**

​					1、适合大规模的数据恢复

​					2、对数据完整性和一致性要求不高，效率比AOP高

​				**缺点：**

​					1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改

​					2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。



​				**AOF 日志:**

​			以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件

​	但不可以改写文件,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

​				**优点：**

​						1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差

但数据完整性比较好

​						2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失

​						3、不同步： appendfsync no 从不同步

​				**缺点：**

​						1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。 

​						2、AOF 运行效率要慢于 RDB，每秒同步策略效率较好，不同步效率和rdb相同。



### redis的事务

​		**Redis事务的概念：**

​				redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

​		**Redis事务没有隔离级别的概念：**

​				批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！

​		**Redis不保证原子性：**

​				redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，

其余的命令仍会被执行。

​		**Redis事务的三个阶段：**

​				开始事务====>>命令入队====>>>执行事务



### 缓存穿透和雪崩

​		**缓存雪崩**

​				**原因：**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

​			**解决方案：**

​					缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

​					互斥锁

​		**缓存穿透**

​				**原因：**缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上

​				**解决方案：**

​					接口层增加校验，如用户鉴权校验，id做基础校验

​					从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

​		**缓存击穿**

​			**原因：**当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访

问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

​			**解决方案：**

​				设置热点数据永不过期

​				加互斥锁



### Redis的过期键的删除策略

​			**惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化

地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而

不会被清除，占用大量内存。

​			**定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其

中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，

可以在不同情况下使得CPU和内存资源达到最优的平衡效果。



### Redis线程模型、单线程快的原因

​		**单线程快的原因：**

​						1）纯内存操作

​						2）核心是基于非阻塞的IO多路复用机制

​						3）单线程反而避免了多线程的频繁上下文切换带来的性能问题





## MQ

#### 简述RabbitMQ的架构设计

​				**Broker**：rabbitmq的服务节点

​				**Queue**：队列，是RabbitMQ的内部对象，用于存储消息。

​				**Exchange**：交换器。生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中。

​				**RoutingKey**：路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定

这个消息的路由规则。

​				**Binding**：通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ

就可以指定如何正确的路由到队列了。

​				**Channel (信道)**：信道是建立在Connection 之上的虚拟连接。

![image-20220628153614152](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220628153614152.png)

​			

#### 消息队列有哪些好处?

1. **解耦：**使⽤消息队列来作为两个系统之间的通讯⽅式，两个系统不需要相互依赖了 

2. **异步：**系统A给消息队列发送完消息之后，就可以继续做其他事情了 

3. **流量削峰：**如果使⽤消息队列的⽅式来调⽤某个系统，那么消息将在队列中排队，由消费者⾃⼰控制消费速度





#### RabbitMQ如何确保消息发送 ？ 消息接收？

​			**发送方确认机制：**信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配一个唯一 ID。 

​					**ConfirmCallback** 接口：只确认是否正确到达 Exchange 中，成功到达则回调 

​					**ReturnCallback **接口：消息失败返回时回调



​			**接收方确认机制：**消费者在声明队列时，可以指定noAck参数，当noAck=false时，RabbitMQ会等待消费者显式发回ack信号 

后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。 





#### RabbitMQ死信队列、延时队列

​		**死信队列**：也是⼀个消息队列，它是⽤来存放那些没有成功消费的消息的，通常可以⽤来作为消息重试。

​			产生死信的三种情况：

​				1、 消息被**消费方否定确认**。

​				2、消息在队列的存货时间**超过设置的TTL时间**。

​				3、消息队列的消息数量已经**超过最大队列长度**。

​		

​		 **延时队列**：就是⽤来存放需要在指定时间被处理的元素的队列，通常可以⽤来处理⼀些具有过期性操 

作的业务，⽐如⼗分钟内未⽀付则取消订单

​		



## 分布式/微服务

#### CAP理论

​		**Consistency (一致性)：**即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。

​		**Availability (可用性)：** **即服务一直可用，而且是正常响应时间。**系统能够很好的为用户服务，不出现用户操作失败或者访问超

时等用户体验不好的情况。

​		**Partition Tolerance (分区容错性)：**即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

​		CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能 2 选 1

#### BASE理论

​		**Basically Available（基本可用）：**基本可⽤是指分布式系统在出现故障的时候，允许损失部分可⽤性，即保证核⼼可⽤。

​		**Soft state（软状态）：**数据同步允许一定的延迟

​		**Eventually consistent（最终一致性）：**最终⼀致性是指系统中的所有数据副本经过⼀定时间后，最终能够达到⼀致的状态。



#### 负载均衡算法、类型

​		**1、轮询法**：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的

连接数和当前的系统负载。

​		**2、随机法**：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。

​		**3、源地址哈希法**：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器

列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。

​		**4、加权轮询法**：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。

​		**5、加权随机法**：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是

按照权重随机请求后端服务器，而非顺序。



#### 分布式架构下，Session共享有什么方案

​		1、**存入cookie**（有安全风险）

​		2、**服务器之间进行 Session 同步**，这样可以保证每个服务器上都有全部的 Session 信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；

​		3、 **IP 绑定策略：**使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但

是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；

​		4、**使用 Redis 存储：**把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来

的好处也是很大的：



#### 分布式id生成方案

​		基于redis、mongodb、zk等中间件生成

​		**雪花算法：**

​				**生成一个64bit的整性数字** 

​				**第一位符号位固定为0，41位时间戳，10位workId，12位序列号位数可以有不同实现** 

​		优点：

​				每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。 

​				时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。 

​				能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。 

​		缺点：

​				强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨， 

​				都会抛异常处 理，阻止ID生成，这可能导致服务不可用。 

#### 分布式锁解决方案

​			**Redis分布式锁：**setNX，单线程处理网络请求，不需要考虑并发安全性所有服务节点设置相同的key，返回为0、则锁获取失败

​				**问题：**存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题

​				可重入性及锁续期没有实现，通过**redisson**解决（类似AQS的实现，看门狗监听机制）



#### 分布式事务解决方案

​		**Seata** **@GlobalTransactional** 注解



#### springcloud 核心组件及其作用

​			**Eureka 、 zookepeer：**服务注册与发现

​					**注册**：每个服务都向Eureka登记自己提供服务的元数据，包括服务的ip地址、端口号、版本号、通信协议等。

​					**发现**：eureka注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单(缓存到本地)，然后实现服务的请求访问。

​			**Ribbon**：服务间发起请求的时候，基于Ribbon做负载均衡

​			**Feign**：我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。

​			**Hystrix**：断路器，发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤

的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级

​			**config**：分布式配置中心

​			**Bus** ：消息总线

​			**GateWay**：网关，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。

​			**SpringCloud Alibaba Nacos**： 服务注册和配置中心

​			**SpringCloud Alibaba Sentinel**： 实现熔断与限流

​			**SpringCloud Alibaba Seata**：处理分布式事务





#### 什么是Hystrix？简述实现机制

​		**是分布式容错框架**：

​				**1、阻止故障的连锁反应，实现熔断**

​				**2、快速失败，实现优雅降级**

​				**3、提供实时的监控和告警**



​		**资源隔离：线程隔离，信号量隔离**

​				**线程隔离：**Hystrix会给每一个Command分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响

​				**信号量隔离：**客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，

当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入fallback流程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。

​		**熔断和降级：**调用服务失败后快速失败

​				**熔断**：**是为了防止异常不扩散，保证系统的稳定性**

​				**降级：**编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不至于直接报错，只是服务水平下降





#### 如何实现接口的幂等性

​			**唯一id：**每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在

​		则执行后续操作，并且保存到数据库或者redis等。

​			**服务端提供发送token的接口：**业务调用接口前先获取token,然后调用业务接口请求时，把token携带过去,

​		务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除

​			**建去重表：**将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了

​			**版本控制：**增加版本号，当版本号符合时，才能更新数据

​			**状态控制：**例如订单有状态已支付 未支付 支付中 支付失败，当处于未支付的时候才允许修改为支付中等



#### 简述ZAB协议

​		zookeeper为了保证数据的⼀致性，使⽤了ZAB（Zookeeper AtomicBroadcast）协议，这个协议解决了Zookeeper的**崩溃恢复和主从数据同步的问题**

​		ZAB 协议包括两种基本的模式：**崩溃恢复和消息广播**

​			**消息广播**：

​			**崩溃恢复**：



#### ZAB协议定义的四种节点状态

​		**Looking**：选举状态

​		**Following**：Follower 从节点所处的状态

​		**Leading**：Leader 主节点所处状态

​		**Observing**：观察者节点所处的状态



#### ZK主从服务器之间的数据同步流程	

#### ![image-20220628113654621](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220628113654621.png)