# 										

## java基础

### java容器

#### 	list集合:

​				**ArrayList 的底层数据结构是什么？LinkedList 的底层数据结构是什么？**

​					ArrayList底层数据结构是数组，LinkedList底层数据结构是链表

​	 		

​			**ArrayList 怎么扩容？一次扩多少？**

​				每一次扩原来的1.5倍。初始化的值为10，当第一11个元素进来的时候会扩容到15，16个元素后扩容到22，空间扩完容之后，会调用arraycopy来对数组进行拷贝。

​			**Vector 你了解吗？**

​				Vector是线程安全的，扩容是原来的两倍（基本不用）



​			**ArrayList 是线程安全的吗？**

​				不是线程安全，多线程的情况下会出现写时覆盖的问题。



​			**那些是线程安全的集合呢？**

​				Vector、 Collections工具类的synchronizedList()方法封装ArrayList、 JUC包下的 CopyOnWriteArrayList



​			**CopyOnWriteArrayList 它的添加元素是怎么实现的**

​				在add()方法其实他会 加lock 锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组。
​				加lock锁，复制就数组，创建一个长度加一的新数组，将元素添加到新数组中，把array的指向改为新数组

​			

​			**CopyOnWriteArrayList 缺点**

​				只能保证**最终一致性**，复制数组 **消耗内存**



#### map集合：

​					![image-20220623160651546](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220623160651546.png)

​	**当new一个HashMap的时候，会发生什么你知道吗？**

​		最主要的就是**指定初始值大小和负载因子的大小**

​		如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75

​		HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。



​	**HashMap动态扩容是扩容多少？**

​			原始大小的**两倍**



​	**为什么HashMap的大小只能是2次幂?**

​		因为只有大小为2次幂时，才能合理用位运算替代取模



​	**在put元素的时候，传递的Key是怎么算哈希值的？**

​		实现就在hash方法上，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。

​        **可以增加了随机性，减少了碰撞冲突的可能性**

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtv6bnxj0hj618q06m3z802.jpg)



​	**简单说下HashMap put流程**

​			**1、计算Hash**

​			**2、是否发生hash碰撞**

​			**3、无碰撞直接进入数组**

​			**4、有碰撞判断此时的数据结构（为红黑树还是链表）**

​			**5、key完全相同时，需要替换**

​			**6、是否需要扩容**



   **那在HashMap中是怎么判断一个元素是否相同的呢？**

​           先比较hash值，随后会用==运算符和equals()来判断该元素是否相同



​    **那什么情况拿下才会用到红黑树呢？**

​			当**数组的大小大于64且链表的大小大于8**的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。



​	**你能给我讲讲JDK 7 和JDK8中HashMap**的区别吗？

​			比如JDK 7 的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7 的HashMap还没有引入红黑树….





### java并发

​		

​		



### java虚拟机













































## Redis

### redis的数据类型有哪些？

​	redis的数据类型有8种，分别是 String、List、Hash、Set、ZSet、地址位置、HyperLoglog、BitMap

### redis的持久化机制有几种？

​	持久化机制有两种：RDB和AOF

​				**RDB 快照：**

​			在指定的时间间隔内将内存中的数据集快照写入磁盘，fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件

​				**优点：**

​					1、适合大规模的数据恢复

​					2、对数据完整性和一致性要求不高，效率比AOP高

​				**缺点：**

​					1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改

​					2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。



​				**AOF 日志:**

​			以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件

​	但不可以改写文件,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

​				**优点：**

​						1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差

但数据完整性比较好

​						2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失

​						3、不同步： appendfsync no 从不同步

​				**缺点：**

​						1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。 

​						2、AOF 运行效率要慢于 RDB，每秒同步策略效率较好，不同步效率和rdb相同。



### redis的事务

​		**Redis事务的概念：**

​				redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

​		**Redis事务没有隔离级别的概念：**

​				批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！

​		**Redis不保证原子性：**

​				redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，

其余的命令仍会被执行。

​		**Redis事务的三个阶段：**

​				开始事务====>>命令入队====>>>执行事务



### 缓存穿透和雪崩

​		**缓存雪崩**

​				**原因：**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

​			**解决方案：**

​					缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

​					互斥锁

​		**缓存穿透**

​				**原因：**缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上

​				**解决方案：**

​					接口层增加校验，如用户鉴权校验，id做基础校验

​					从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

​		**缓存击穿**

​			**原因：**当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访

问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

​			**解决方案：**

​				设置热点数据永不过期

​				加互斥锁



### Redis的过期键的删除策略

​			**惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化

地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而

不会被清除，占用大量内存。

​			**定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其

中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，

可以在不同情况下使得CPU和内存资源达到最优的平衡效果。



### Redis线程模型、单线程快的原因

​		**单线程快的原因：**

​						1）纯内存操作

​						2）核心是基于非阻塞的IO多路复用机制

​						3）单线程反而避免了多线程的频繁上下文切换带来的性能问题