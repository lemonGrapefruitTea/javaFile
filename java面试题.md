# 										

## java基础

### java容器

#### 	list集合

#### ArrayList 的底层数据结构是什么？

​			ArrayList底层数据结构是数组

#### LinkedList 的底层数据结构是什么？

​			LinkedList底层数据结构是链表

#### ArrayList 怎么扩容？一次扩多少？

​			每一次扩原来的1.5倍。初始化的值为10，当第一11个元素进来的时候会扩容到15，16个元素后扩容到22，空间扩完容之后，会调用arraycopy来对数组进行拷贝。

#### Vector 你了解吗？

​			Vector是线程安全的，扩容是原来的两倍（基本不用）



#### ArrayList 是线程安全的吗？

​			不是线程安全，多线程的情况下会出现写时覆盖的问题。



#### 那些是线程安全的集合呢？

​				Vector、 Collections工具类的synchronizedList()方法封装ArrayList、 JUC包下的 CopyOnWriteArrayList



#### CopyOnWriteArrayList 它的添加元素是怎么实现的

​				在add()方法其实他会 加lock 锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组。
​				加lock锁，复制旧数组，创建一个长度加一的新数组，将元素添加到新数组中，把array的指向改为新数组

​			

#### 	CopyOnWriteArrayList 缺点

​				只能保证**最终一致性**，复制数组 **消耗内存**



#### map集合

​					![image-20220623160651546](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220623160651546.png)

​	**当new一个HashMap的时候，会发生什么你知道吗？**

​		最主要的就是**指定初始值大小和负载因子的大小**

​		如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75

​		HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。



​	**HashMap动态扩容是扩容多少？**

​			原始大小的**两倍**



​	**为什么HashMap的大小只能是2次幂?**

​		因为只有大小为2次幂时，才能合理用位运算替代取模



​	**在put元素的时候，传递的Key是怎么算哈希值的？**

​		实现就在hash方法上，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。

​        **可以增加了随机性，减少了碰撞冲突的可能性**

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtv6bnxj0hj618q06m3z802.jpg)



​	**简单说下HashMap put流程**

​			**1、计算Hash**

​			**2、是否发生hash碰撞**

​			**3、无碰撞直接进入数组**

​			**4、有碰撞判断此时的数据结构（为红黑树还是链表）**

​			**5、key完全相同时，需要替换**

​			**6、是否需要扩容**



   **那在HashMap中是怎么判断一个元素是否相同的呢？**

​           先比较hash值，随后会用==运算符和equals()来判断该元素是否相同



​    **那什么情况拿下才会用到红黑树呢？**

​			**当数组的大小大于64且链表的大小大于8**的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。



​	**你能给我讲讲JDK 7 和JDK8中HashMap**的区别吗？

​			比如JDK 7 的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7 的HashMap还没有引入红黑树….





### java并发

#### 		wait和sleep有什么区别？

​				1、sleep是Thread类的静态方法，wait是Object的方法

​				2、sleep不会释放锁，wai会释放锁

​				3、sleep不依赖synchronized，wait依赖synchronized

​				4、slepp必须要捕获异常，wait不需要捕获异常



#### 		synchronized 和 Lock 区别?

​				1、Synchronized 内置的Java关键字， Lock 是一个Java类

​				2、Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁，**死锁**

​				3、Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；

​				4、Synchronized 可重入锁，非公平，不可以中断的；Lock ，可重入锁，非公平（可以自己设置），可以 判断锁



#### 		 什么是JMM？

​				JMM ： Java内存模型，是一种概念！约定！（不存在的东西）

​		

#### 		关于JMM的一些同步的约定

​				1、线程解锁前，必须把共享变量**立刻**刷回主存。

​				2、线程加锁前，必须读取主存中的最新值到工作内存中！

​				3、加锁和解锁是同一把锁



#### 		谈谈你对 volatile 的理解

​				volatile是java虚拟机提供**轻量级的同步机制**，特性：**保证可见性、不保证原子性、禁止指令重排**



#### 		什么是CAS？

​				**比较并交换**，比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作，如果不是就一直循环！

​				**缺点：**循环会耗时、一次性只能保证一个共享变量的原子性、ABA问题

​		

##### 		原子引用

​				使用  **AtomicStampedReference** 解决ABA问题，引入原子引用，它的对应思想就是：**乐观锁**



#### 什么是公平锁、非公平锁？

​				**公平锁：**非常公平，不能够插队，必须先来后到

​				**非公平锁：**非常不公平，可以插队



#### 什么是可重入锁？

​				可重入锁（递归锁），意思就是当拿到了外层的锁之后，就可以拿到里面的锁，自动获得锁，前提是**同一个锁对象**。

​		

#### 什么是死锁，导致死锁的原因是什么？

​		A对象持有A锁，试图获取B锁，B对象持有B锁，试图获取A锁。



#### 死锁怎么排除？

​		1、使用 **jps -l** 定位进程号

​		2、使用 **jstack 进程号** 找到死锁问题



#### 什么是读写锁？

​		**独占锁（写锁）**：一次只能被一个线程占有

​		**共享锁（读锁）**：多个线程可以同时占有

​		

#### CountDownLatch、CyclicBarrier、Semaphore辅助类分别有什么用？

​		**CountDownLatch：**每次有线程调用countDown()方法数量 -1 ，假设计数器变为0， countDownLatch.await() 就会被唤醒，继续执行！（这是一个一次性的现象）

​		**CyclicBarrier：**允许一组线程全部等待彼此达到共同屏障点的同步辅助。（加法计数器）

​		**Semaphore：一个计数信号量**

​				semaphore.acquire() 获得，假设如果已经满了，等待，等待被释放为止！

​				semaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！

​				**作用：**多个共享资源互斥的使用！并发限流，控制最大的线程数！



#### 什么是阻塞队列？

​		BlockingQueue**：写入：如果队列满了，就必须阻塞等待，取：如果队列是空的，必须阻塞等待生产



#### 使用线程池的好处是什么？

​		1、降低资源的消耗  2、提高响应的速度   3、方便管理

**线程可以复用、可以控制最大并发数、管理线程**

​		

#### 线程池的参数有哪些？

​		有7个： 核心线程数	最大线程数	空闲存活时间	空闲存活时间单位	阻塞队列	线程工厂	拒绝策略

​		

#### 线程池的复用原理

​		核心原理在于线程池对Thread进行了封装，每个线程去执行 循环任务，如果有任务则直接执行。

​		

### java虚拟机

#### 	

#### Java文件执行的过程是什么样子的？

![image-20220624114210925](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624114210925.png)

​		

#### Java类加载器有哪些？

​				JDK自带有三个类加载器：**bootstrap ClassLoader、ExtClassLoader、AppClassLoader**

​				**bootstrap ClassLoader：**负责加载 %JAVA_HOME%lib 下的jar包和class

​				**ExtClassLoader：**负责加载 %JAVA_HOME%/lib/ext 文件夹下的jar包和class

​				AppClassLoader:**  负责加载classpath下的类文件



#### 双亲委托模型

​				**向上委派：**实际上就是查找缓存是否加载了该类，有则直接返回，没有继续向上

​				**向下查找：**查找加载路径，有则加载返回，没有则继续向下查找

​				**好处：**主要是为了**安全性**，**避免用户自己编写的类动态替换 Java的一些核心类**，比如 String。

​						**同时也避免了类的重复加载**，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不

​				同的 ClassLoader加载就是不同的两个类

​		

#### JVM内存结构

​				**虚拟机栈：**在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。

​				**本地方法栈：**本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是native方法

​				**程序计数器：**主要用来记录各个线程执行的字节码地址

​				**方法区：**JDK7及之前叫 " 永久代 "，JDK8及之后  " 元空间 " ，存放类的信息，常量池、方法数据、方法代码

​				**堆：** 堆是JVM上最大的内存区域，我们申请的几乎所有的对象，都是存储在堆中。



![img](https://tva1.sinaimg.cn/large/008i3skNgy1gs784qdq5sj314z0u04dh.jpg)



#### JVM中 虚拟机栈

​				每个线程在创建的时候都会创建一个 【虚拟机栈】，每次方法调用都会创建一个 【栈桢】，每个 【栈桢】会包含几个内容：**局部变量表、操作数栈、动态链接、返回地址**

​				![image-20220624155741991](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624155741991.png)



#### JVM中 堆的内存区域

​			【堆】是线程共享的区域，几乎类的实例和数组分配内存都来自它

​			【堆】被划分为 【新生代】和 【老年代】，【新生代】又被划分为 Eden 和 Survivor 区，Survivor区由 S0 S1组成



​			![image-20220624162854954](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624162854954.png)



#### 永久代 变成 元空间 后，它们有什么区别吗？

​			最主要的区别就是：[ 元空间 ] 存储不在虚拟机中，而是使用本地内存**，JVM不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。



####  	垃圾回收机制

​			**GC是如何判断对象可以被回收的？**

​						**引用计数法：**每个对象有一个引用计数属性，新增一个引用计数器加1，引用释放计数器减1，0时可以回收（不推荐）

​						**可达性分析法：**它从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收

​			**GC Roots的对象有那些？：**

​							**虚拟机栈中引用的对象**

​							**方法区中静态属性引用的对象**

​							**方法区中常量引用的对象**	

​							**本地方法栈中引用的对象**

​						

#### 常见的垃圾回收算法有那些？

​			标记清除、标记复制、标记整理





### JVM调优



#### 你平时工作用过的jvm调优参数有哪儿些？

- **-Xms**	堆初始大小内存，默认为物理内存 1/61 

  - **-Xmx**   堆最大分配内存，默认为物理内存的 1/4

  - **-Xss**    设置单个线程的大小，一般默认为 512K ~ 1024K

  - **-Xmn**    设置年轻代大小

  - **-XX:MetaspaceSize**   设置元空间大小

  - **-XX:+PrintGCDetails**  输出详细GC收集日志信息

    

#### 强引用、软引用、弱引用、虚引用分别是什么?

​			**强引用：**就算是出现了OOM也不会对该对象进行回收

​			**软引用：**内存够用的时候就保留，不够用就回收

​			**弱引用：**不管内存是否够用都回收

​			**虚引用：**虚引用必定被回收



#### 谈谈见过的OOM异常

- Java.lang.StackOverflowError   使用方法递归调用的时候可能会出现
- Java.lang.OutOfMemoryError:Java heap space   堆内存溢出
- Java.lang.OutOfMemeoryError:Metaspace   元空间内存溢出



#### 生产环境服务器变慢，诊断思路和性能评估谈谈?

1. jps: 虚拟机进程状态工具
2. jinfo： java配置信息工具
3. jmap：内存映像工具
4. jstat：统计信息监控工具







## Spring



#### 什么是Spring？

​			spring是一个轻量级、面向切面的容器框架，主要核心有IOC、AOP



#### 谈谈你对AOP的理解？

​			AOP: 是将程序中交叉业务逻辑，比如安全、日志、事物等等，封装成一个切面，然后注入到目标对象中去，也就是具体的业务逻辑中去。

​			AOP可以对某些对象的功能进行增强，比如增强目标对象中的方法，还可以在执行某个方法之前或者之后额外做一些事情。



#### 谈谈你对IOC的理解？

​			IOC容器有三大核心点：**IOC容器**、**控制反转**、**依赖注入**

​			**IOC容器：**实际上就是一个map，里面存放各种对象，在项目启动的时候会读取配置文件里面的bean节点，和扫描添加了@Service、@Controller、@Component、@repository注解的类，通过反射创建对象到map里面，需要使用是就可以用@Autowired、@Resource 注解获取到对象

​			**控制反转：**如果没有引入IOC容器之前，对象A调用对象B的过程是需要我们自己去创建的，引入

​			**依赖注入：**依赖注入是实现IOC容器的方法，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象中去。



#### 描述一下bean的生命周期？

​			1、解析类得到BeanDefinition

​			2、如果有多个构造方法则需要推断构造方法

​			3、确定好构造方法后，进行实例化得到一个对象

​			4、对对象中加了@Autowired注解的属性进行属性填充

​			5、回调Aware方法

​			6、调用BeanPostProcessor的初始化前的方法，调用初始化方法

​			7、调用BeanPostProcessor的初始化后的方法，这里会进行AOP处理

​			8、如果当前创建的bean是单例的，则会把bean放出单例池

​			9、使用bean

​			10、Spring容器关闭时调用DisposableBean中destory方法

​			到此整个生命周期结束



#### Spring中单例bean是线程安全的吗？

​			**不是线程安全，**Spring容器并没有对单例的bean进行线程安全的处理。



#### BeanFactory和ApplicationContext有什么区别？

​			**BeanFactory** 采用的是延迟加载的形式来注入Bean的。

​			**ApplicationContext**  是在容器启动时，一次性加载了所有的Bean。



#### Spring框架中的设计模式都有那些？

​			工厂模式：

​			原型模式：

​			单例模式：

​			构造器模式：

​			适配器模式：

​			装饰器模式：

​			动态代理：

​			观察者模式：

​			策略模式：



#### Spring事物的实现方式和隔离级别？

​			在使用Spring框架时，可以有两种使用事务的方式，一种是编程式（自己写 commit ）、一种是申明式的（@Transactional）

​			**@Transactional：**在方法上加了 @Transactional 注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，如果这个方法上存在 @Transactional 注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行业务逻辑方法，如果执行业务逻辑方法没有异常，将事务进行提交，如果有异常，则进行事务回滚。 



#### Spring事物什么时候会失效？

​			1、发生调用，类⾥⾯使⽤this调⽤本类的⽅法

​			2、方法不是public的，@Transactionl 事务不会生效

​			3、数据库不支持事务

​			4、没有被spring管理

​			5、异常被吃掉，事务不会回滚



#### 什么是bean的自动装配，有哪些方式？

​			开启自动装配，只需要在xml配置文件中定义 autowire 属性，可以根据 

​			**byName**：属性名进行自动装配  或者 **byType**：类型进行自动装配



#### Spring的三级缓存你知道吗？

​			![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtyval7yubj60va0g8gmb02.jpg)

​		Spring的三级缓存其实就是三个**Map**

​		**singletonObjects：** 一级，日常实际获取Bean的地方

​		**earlySingletonObjects：**二级，还没进行属性注入，由三级缓存放进来

​		**singletonFactories：**三级，Value是一个对象工厂

​		**执行流程：**

​					1、**A** 创建过程中需要 **B**，于是 **A** 将自己放到三级缓存里面，去实例化 **B**

​					2、**B** 实例化的时候发现需要 **A** ，于是 **B** 先查一级缓存，发现没有，再查二级缓存，还是没有，再查三级缓存，

​			找到了A，然后把三级缓存里面的这个 **A** 放到二级缓存里面，并删除三级缓存里面的 **A**

​					3、**B **顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态），然后回来接着创建 **A**，

​			此时B已经创建结束，直接从一级缓存里面拿到 **B**，然后完成创建，并将A自己放到一级缓存里面。

#### Spring依赖注入有几种方式？

​		有四种：**set()方法注入 、 构造器注入、 基于注解的注入**

#### Spring怎么解决循环依赖的问题？

​		Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过**三级缓存**来解决的。







## SpringBoot



#### Spring Boot中常用注解基底层

​		1、**@SrpingBootApplication** 注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，

这三个注解是：

​				a. **@SpringBootConfiguration**： 这个注解实际就是一个 @Configuration，表示启动类也是一个配置类

​				b. **@EnableAutoConfiguration**： 向Spring容器中导入一个Selector，用来加载ClassPath下 SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean

​				c. **@ComponentScan**：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前⽬录 

​		 2、**@Bean**注解：⽤来定义Bean，类似于XML中的**<bean>**标签，Spring在启动时，会对加了@Bean注 

解的⽅法进⾏解析，将⽅法的名字做为beanName，并通过执⾏⽅法得到bean对象 

​		3、**@Controller、@Service、@ResponseBody、@Autowired**都可以说 



#### SpringBoot 是如何启动Tomcat的

​		1、⾸先，SpringBoot在启动时会先创建⼀个Spring容器 

​		2、在创建Spring容器过程中，会利⽤**@ConditionalOnClass**技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会⽣成⼀个启动Tomcat的Bean 

​		3、Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端⼝等，然后启动Tomcat 





## MySql

#### 索引的基本原理是什么？	

​		索引的原理：**就是把无序的数据变为有序的查询**

​		

#### 索引设计的原则有哪些？

  1. 适合索引的列是出现在where子句中的列

  2. 基数较小的表，没有必要在此列建立索引

  3. 更新频繁字段不适合创建索引

  4. 若是不能有效区分数据的列不适合做索引列 (如男、女、未知，最多就三种，区分实在太低)

  5. 尽量的扩展索引，不要新建索引。

  6. 过度索引会消耗磁盘空间。

     

#### 锁的类型有哪些？

​		**共享锁  (读锁)：**数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。（避免出现重复读的问题）

​		**排他锁（写锁）：**数据加上写锁后，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。（避免了出现脏数据和脏读的问题）

​		**表锁：**表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能 

进行对表进行访问；		

​		**行锁：**行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不 

能访问，其他的记录可正常访问； 



#### 对慢查询的SQL怎么优化？

​		**首先分析语句：**看看是不是加载了额外的数据，可能查询多余的行并且抛弃掉了，可能加载了许多并不需要的列，对语句进行分析重写。

​		**分析语句的执行计划：**然后获得其使用索引的情况，修改语句或者修改索引，使得语句尽可能的命中索引。

​		如果前两步都无法进行优化，那么就要考虑是不是数据量太大了，就需要进行横向或者纵向的分表啦





#### 事务的基本特性是什么？

​		**原子性：**是一个事务中的操作要么全部成功，要么全部失败（底层依赖 **undo log** 来实现）

​		**一致性：**一致性是事务的目的，需要通过应用程序来保证一致性（原子性、隔离性、持久性均是**为了保障一致性的手段**）

​		**隔离性：**事务之间需要有隔离，互不影响 （隔离级别底层是**锁**）

​		**持久性：**是一旦事务提交，所做的修改就会永久保存到数据库中（而持久性由 **redo log** 日志来保证）



#### 事务的隔离级别有哪些？

​		**read uncommit 读未提交：**可能会读到其他事务未提交的数据，也叫做脏读。

​		**read commit 读已提交：**两次读取结果不一致，叫做不可重复读。

​		**repeatable read 可重复复读：**这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。

​		**serializable 串行：**一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

​			**脏读：**某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事	务所读取的数据就会是不正确的。

​			**不可重复读：**在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

​			**幻读：**在一个事务的两次查询中数据笔数不一致



#### ACID靠什么保证的？

​		**A 原子性由undo log日志保证**，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

​		**C 一致性由其他三大特性保证**、程序代码要保证业务上的一致性

​		**I 隔离性由MVCC来保证**

​		**D 持久性由内存+redo log来保证**，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可

​		以从redo log恢复



#### 什么是MVCC？

​		MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同

实现不同的隔离级别。



#### 简述MyISAM和InnoDB的区别

​		**MyISAM：**

​			**不支持事务，但是每次查询都是原子的**

​			**支持表级锁，每次操作都是对真个表加锁**

​			**存储表的总行数**

​		**InnoDb：**

​			**支持ACID的事务，支持事务的四种隔离级别**

​			**支持行级锁及外键约束，可以支持写并发**

​			**不存储总行数**



#### mysql聚簇和非聚簇索引的区别?

​		**都是B+树的数据结构**

​		**聚簇索引：**将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数

据，数据的物理存放顺序与索引顺序是一致的

​		**非聚簇索引：**叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置

再取磁盘查找数据



## Redis

### redis的数据类型有哪些？

​	redis的数据类型有8种，分别是 String、List、Hash、Set、ZSet、地址位置、HyperLoglog、BitMap



### redis的持久化机制有几种？

​	持久化机制有两种：RDB和AOF

​				**RDB 快照：**

​			在指定的时间间隔内将内存中的数据集快照写入磁盘，fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件

​				**优点：**

​					1、适合大规模的数据恢复

​					2、对数据完整性和一致性要求不高，效率比AOP高

​				**缺点：**

​					1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改

​					2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。



​				**AOF 日志:**

​			以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件

​	但不可以改写文件,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

​				**优点：**

​						1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差

但数据完整性比较好

​						2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失

​						3、不同步： appendfsync no 从不同步

​				**缺点：**

​						1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。 

​						2、AOF 运行效率要慢于 RDB，每秒同步策略效率较好，不同步效率和rdb相同。



### redis的事务

​		**Redis事务的概念：**

​				redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

​		**Redis事务没有隔离级别的概念：**

​				批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！

​		**Redis不保证原子性：**

​				redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，

其余的命令仍会被执行。

​		**Redis事务的三个阶段：**

​				开始事务====>>命令入队====>>>执行事务



### 缓存穿透和雪崩

​		**缓存雪崩**

​				**原因：**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

​			**解决方案：**

​					缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

​					互斥锁

​		**缓存穿透**

​				**原因：**缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上

​				**解决方案：**

​					接口层增加校验，如用户鉴权校验，id做基础校验

​					从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

​		**缓存击穿**

​			**原因：**当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访

问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

​			**解决方案：**

​				设置热点数据永不过期

​				加互斥锁



### Redis的过期键的删除策略

​			**惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化

地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而

不会被清除，占用大量内存。

​			**定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其

中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，

可以在不同情况下使得CPU和内存资源达到最优的平衡效果。



### Redis线程模型、单线程快的原因

​		**单线程快的原因：**

​						1）纯内存操作

​						2）核心是基于非阻塞的IO多路复用机制

​						3）单线程反而避免了多线程的频繁上下文切换带来的性能问题





## MQ

​	



## 分布式/微服务

#### CAP理论

#### BASE理论

#### 负载均衡算法、类型

#### 分布式架构下，Session共享有什么方案

#### 简述你对RPC、RMI的理解

#### 分布式id生成方案

#### 分布式锁解决方案

#### 分布式事务解决方案

#### 如何实现接口的幂等性

#### 简述ZAB协议