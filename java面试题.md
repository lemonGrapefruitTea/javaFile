# 										

## java基础

### java容器

#### 	list集合:

​			**ArrayList 的底层数据结构是什么？LinkedList 的底层数据结构是什么？**

​				ArrayList底层数据结构是数组，LinkedList底层数据结构是链表

​	 		

​			**ArrayList 怎么扩容？一次扩多少？**

​				每一次扩原来的1.5倍。初始化的值为10，当第一11个元素进来的时候会扩容到15，16个元素后扩容到22，空间扩完容之后，会调用arraycopy来对数组进行拷贝。

​			**Vector 你了解吗？**

​				Vector是线程安全的，扩容是原来的两倍（基本不用）



​			**ArrayList 是线程安全的吗？**

​				不是线程安全，多线程的情况下会出现写时覆盖的问题。



​			**那些是线程安全的集合呢？**

​				Vector、 Collections工具类的synchronizedList()方法封装ArrayList、 JUC包下的 CopyOnWriteArrayList



​			**CopyOnWriteArrayList 它的添加元素是怎么实现的**

​				在add()方法其实他会 加lock 锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组。
​				加lock锁，复制旧数组，创建一个长度加一的新数组，将元素添加到新数组中，把array的指向改为新数组

​			

​			**CopyOnWriteArrayList 缺点**

​				只能保证**最终一致性**，复制数组 **消耗内存**



#### map集合：

​					![image-20220623160651546](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220623160651546.png)

​	**当new一个HashMap的时候，会发生什么你知道吗？**

​		最主要的就是**指定初始值大小和负载因子的大小**

​		如果我们不指定，默认HashMap的大小为16，负载因子的大小为0.75

​		HashMap的大小只能是2次幂的，假设你传一个10进去，实际上最终HashMap的大小是16，你传一个7进去，HashMap最终的大小是8，具体的实现在tableSizeFor可以看到。



​	**HashMap动态扩容是扩容多少？**

​			原始大小的**两倍**



​	**为什么HashMap的大小只能是2次幂?**

​		因为只有大小为2次幂时，才能合理用位运算替代取模



​	**在put元素的时候，传递的Key是怎么算哈希值的？**

​		实现就在hash方法上，它是先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。

​        **可以增加了随机性，减少了碰撞冲突的可能性**

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gtv6bnxj0hj618q06m3z802.jpg)



​	**简单说下HashMap put流程**

​			**1、计算Hash**

​			**2、是否发生hash碰撞**

​			**3、无碰撞直接进入数组**

​			**4、有碰撞判断此时的数据结构（为红黑树还是链表）**

​			**5、key完全相同时，需要替换**

​			**6、是否需要扩容**



   **那在HashMap中是怎么判断一个元素是否相同的呢？**

​           先比较hash值，随后会用==运算符和equals()来判断该元素是否相同



​    **那什么情况拿下才会用到红黑树呢？**

​			**当数组的大小大于64且链表的大小大于8**的时候才会将链表改为红黑树，当红黑树大小为6时，会退化为链表。



​	**你能给我讲讲JDK 7 和JDK8中HashMap**的区别吗？

​			比如JDK 7 的HashMap在扩容时是头插法，在JDK8就变成了尾插法，在JDK7 的HashMap还没有引入红黑树….





### java并发

#### 		**wait和sleep有什么区别？**

​				1、sleep是Thread类的静态方法，wait是Object的方法

​				2、sleep不会释放锁，wai会释放锁

​				3、sleep不依赖synchronized，wait依赖synchronized

​				4、slepp必须要捕获异常，wait不需要捕获异常



#### 		**synchronized 和 Lock 区别?**

​				1、Synchronized 内置的Java关键字， Lock 是一个Java类

​				2、Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁，**死锁**

​				3、Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；

​				4、Synchronized 可重入锁，非公平，不可以中断的；Lock ，可重入锁，非公平（可以自己设置），可以 判断锁



​		 **什么是JMM？**

​				JMM ： Java内存模型，是一种概念！约定！（不存在的东西）

​		

​		**关于JMM的一些同步的约定**

​				1、线程解锁前，必须把共享变量**立刻**刷回主存。

​				2、线程加锁前，必须读取主存中的最新值到工作内存中！

​				3、加锁和解锁是同一把锁



​		**谈谈你对 volatile 的理解**、

​				volatile是java虚拟机提供**轻量级的同步机制**，特性：**保证可见性、不保证原子性、禁止指令重排**



​		**什么是CAS？**

​				**比较并交换**，比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作，如果不是就一直循环！

​				**缺点：**循环会耗时、一次性只能保证一个共享变量的原子性、ABA问题

​		

​		**原子引用**

​				使用  **AtomicStampedReference** 解决ABA问题，引入原子引用，它的对应思想就是：**乐观锁**



​		**什么是公平锁、非公平锁？**

​				**公平锁：**非常公平，不能够插队，必须先来后到

​				**非公平锁：**非常不公平，可以插队



​		**什么是可重入锁？**

​				可重入锁（递归锁），意思就是当拿到了外层的锁之后，就可以拿到里面的锁，自动获得锁，前提是**同一个锁对象**。

​		

​		**什么是死锁，导致死锁的原因是什么？**

​				A对象持有A锁，试图获取B锁，B对象持有B锁，试图获取A锁。



​		**死锁怎么排除？**

​				1、使用 **jps -l** 定位进程号

​				2、使用 **jstack 进程号** 找到死锁问题



​		**什么是读写锁？**

​				**独占锁（写锁）**：一次只能被一个线程占有

​				**共享锁（读锁）**：多个线程可以同时占有

​		

​		**CountDownLatch、CyclicBarrier、Semaphore辅助类分别有什么用？**

​				**CountDownLatch：**每次有线程调用countDown()方法数量 -1 ，假设计数器变为0， countDownLatch.await() 就会被唤醒，继续执行！（这是一个一次性的现象）

​				**CyclicBarrier：**允许一组线程全部等待彼此达到共同屏障点的同步辅助。（加法计数器）

​				**Semaphore：一个计数信号量**

​						semaphore.acquire() 获得，假设如果已经满了，等待，等待被释放为止！

​						semaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！

​						**作用：**多个共享资源互斥的使用！并发限流，控制最大的线程数！



​		**什么是阻塞队列？**

​				**BlockingQueue**：写入：如果队列满了，就必须阻塞等待，取：如果队列是空的，必须阻塞等待生产



​		**使用线程池的好处是什么？**

​				1、降低资源的消耗  2、提高响应的速度   3、方便管理

​		     **线程可以复用、可以控制最大并发数、管理线程**

​		

​		**线程池的参数有哪些？**

​				有7个： 核心线程数	最大线程数	空闲存活时间	空闲存活时间单位	阻塞队列	线程工厂	拒绝策略

​		

​		**线程池的复用原理**

​				核心原理在于线程池对Thread进行了封装，每个线程去执行 循环任务，如果有任务则直接执行。

​		

### java虚拟机

#### 	JVM模型



​		**Java文件执行的过程是什么样子的？**

![image-20220624114210925](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624114210925.png)

​		

​		**Java类加载器有哪些？**

​				JDK自带有三个类加载器：**bootstrap ClassLoader、ExtClassLoader、AppClassLoader**

​					**bootstrap ClassLoader：**负责加载 %JAVA_HOME%lib 下的jar包和class

​					**ExtClassLoader：**负责加载 %JAVA_HOME%/lib/ext 文件夹下的jar包和class

​					**AppClassLoader:**  负责加载classpath下的类文件



​		**双亲委托模型**

​				**向上委派：**实际上就是查找缓存是否加载了该类，有则直接返回，没有继续向上

​				**向下查找：**查找加载路径，有则加载返回，没有则继续向下查找

​				**好处：**主要是为了**安全性**，**避免用户自己编写的类动态替换 Java的一些核心类**，比如 String。

​						**同时也避免了类的重复加载**，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不

​				同的 ClassLoader加载就是不同的两个类

​		

​		**JVM内存结构**

​				**虚拟机栈：**在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。

​				**本地方法栈：**本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是native方法

​				**程序计数器：**主要用来记录各个线程执行的字节码地址

​				**方法区：**JDK7及之前叫 " 永久代 "，JDK8及之后  " 元空间 " ，存放类的信息，常量池、方法数据、方法代码

​				**堆：** 堆是JVM上最大的内存区域，我们申请的几乎所有的对象，都是存储在堆中。



![img](https://tva1.sinaimg.cn/large/008i3skNgy1gs784qdq5sj314z0u04dh.jpg)



​			**JVM中 虚拟机栈** 

​						每个线程在创建的时候都会创建一个 【虚拟机栈】，每次方法调用都会创建一个 【栈桢】，每个 【栈桢】会包含

​			几个内容：**局部变量表、操作数栈、动态链接、返回地址**

​				![image-20220624155741991](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624155741991.png)



​			**JVM中 堆的内存区域**

​					【堆】是线程共享的区域，几乎类的实例和数组分配内存都来自它

​					【堆】被划分为 【新生代】和 【老年代】，【新生代】又被划分为 Eden 和 Survivor 区，Survivor区由 S0 S1组成



​					![image-20220624162854954](C:\Users\paojiao\AppData\Roaming\Typora\typora-user-images\image-20220624162854954.png)



​			**永久代 变成 元空间 后，它们有什么区别吗？**

​						**最主要的区别就是：[ 元空间 ] 存储不在虚拟机中，而是使用本地内存**，JVM不会再出现方法区的内存溢出，以往「永久代」经常因为内存不够用导致跑出OOM异常。



####  	垃圾回收机制

​			**GC是如何判断对象可以被回收的？**

​						**引用计数法：**每个对象有一个引用计数属性，新增一个引用计数器加1，引用释放计数器减1，0时可以回收（不推荐）

​						**可达性分析法：**它从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收

​			**GC Roots的对象有那些？：**

​							**虚拟机栈中引用的对象**

​							**方法区中静态属性引用的对象**

​							**方法区中常量引用的对象**	

​							**本地方法栈中引用的对象**

​						

​			**常见的垃圾回收算法有那些？**

​					标记清除、标记复制、标记整理





#### JVM调优



**你平时工作用过的jvm调优参数有哪儿些？**

- **-Xms**	堆初始大小内存，默认为物理内存 1/61 

  - **-Xmx**   堆最大分配内存，默认为物理内存的 1/4

  - **-Xss**    设置单个线程的大小，一般默认为 512K ~ 1024K

  - **-Xmn**    设置年轻代大小

  - **-XX:MetaspaceSize**   设置元空间大小

  - **-XX:+PrintGCDetails**  输出详细GC收集日志信息

    

**强引用、软引用、弱引用、虚引用分别是什么?**

​			**强引用：**就算是出现了OOM也不会对该对象进行回收

​			**软引用：**内存够用的时候就保留，不够用就回收

​			**弱引用：**不管内存是否够用都回收

​			**虚引用：**虚引用必定被回收



**谈谈见过的OOM异常**

- Java.lang.StackOverflowError   使用方法递归调用的时候可能会出现
- Java.lang.OutOfMemoryError:Java heap space   堆内存溢出
- Java.lang.OutOfMemeoryError:Metaspace   元空间内存溢出



**生产环境服务器变慢，诊断思路和性能评估谈谈?**

1. 





## Redis

### redis的数据类型有哪些？

​	redis的数据类型有8种，分别是 String、List、Hash、Set、ZSet、地址位置、HyperLoglog、BitMap



### redis的持久化机制有几种？

​	持久化机制有两种：RDB和AOF

​				**RDB 快照：**

​			在指定的时间间隔内将内存中的数据集快照写入磁盘，fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件

​				**优点：**

​					1、适合大规模的数据恢复

​					2、对数据完整性和一致性要求不高，效率比AOP高

​				**缺点：**

​					1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改

​					2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。



​				**AOF 日志:**

​			以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件

​	但不可以改写文件,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

​				**优点：**

​						1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差

但数据完整性比较好

​						2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失

​						3、不同步： appendfsync no 从不同步

​				**缺点：**

​						1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。 

​						2、AOF 运行效率要慢于 RDB，每秒同步策略效率较好，不同步效率和rdb相同。



### redis的事务

​		**Redis事务的概念：**

​				redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

​		**Redis事务没有隔离级别的概念：**

​				批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！

​		**Redis不保证原子性：**

​				redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，

其余的命令仍会被执行。

​		**Redis事务的三个阶段：**

​				开始事务====>>命令入队====>>>执行事务



### 缓存穿透和雪崩

​		**缓存雪崩**

​				**原因：**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

​			**解决方案：**

​					缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

​					互斥锁

​		**缓存穿透**

​				**原因：**缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上

​				**解决方案：**

​					接口层增加校验，如用户鉴权校验，id做基础校验

​					从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

​		**缓存击穿**

​			**原因：**当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访

问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

​			**解决方案：**

​				设置热点数据永不过期

​				加互斥锁



### Redis的过期键的删除策略

​			**惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化

地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而

不会被清除，占用大量内存。

​			**定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其

中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，

可以在不同情况下使得CPU和内存资源达到最优的平衡效果。



### Redis线程模型、单线程快的原因

​		**单线程快的原因：**

​						1）纯内存操作

​						2）核心是基于非阻塞的IO多路复用机制

​						3）单线程反而避免了多线程的频繁上下文切换带来的性能问题